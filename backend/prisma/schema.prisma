// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  USER
}

model User {
  id            String   @id @default(uuid())
  username      String   @unique
  email         String   @unique
  passwordHash  String   @map("password_hash")
  firstName     String?  @map("first_name")
  lastName      String?  @map("last_name")
  bio           String?
  
  // Storage-based files (stored in our CDN/R2)
  fileDirectory String?  @map("file_directory") // Format: yyyy/mm/dd based on createdAt
  avatar        String?  // Filename only (e.g., "avatar-uuid.jpg")
  banner        String?  // Filename only (e.g., "banner-uuid.jpg")
  
  // External URLs (for users who provide their own URLs)
  avatarUrl     String?  @map("avatar_url")
  bannerUrl     String?  @map("banner_url")
  
  role          UserRole @default(USER)
  isVerified    Boolean  @default(false) @map("is_verified")
  isActive      Boolean  @default(true) @map("is_active")
  coinBalance   Int      @default(0) @map("coin_balance")
  isVip         Boolean  @default(false) @map("is_vip")
  verificationToken String? @map("verification_token")
  verificationTokenExpiry DateTime? @map("verification_token_expiry")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  videos         Video[]
  posts          CommunityPost[]
  comments       Comment[]
  likes          Like[]
  playlists      Playlist[]
  followers      Follow[] @relation("UserFollowers")
  following      Follow[] @relation("UserFollowing")
  reports        UserReport[] @relation("UserReports")
  reported       UserReport[] @relation("UserReported")
  blocks         UserBlock[] @relation("UserBlocks")
  blocked        UserBlock[] @relation("UserBlocked")
  chatRooms      ChatRoom[] @relation("ChatRoomCreator")
  chatMessages   ChatMessage[]
  chatRoomParticipants ChatRoomParticipant[]
  
  // Community post interactions
  postLikes      CommunityPostLike[] @relation("UserLikes")
  postBookmarks  CommunityPostBookmark[] @relation("UserBookmarks")
  postReports    CommunityPostReport[] @relation("UserReports")
  
  // Payments
  payments       Payment[]
  unlockedPosts  UnlockedPost[]
  
  // Coin Transactions
  coinTransactions CoinTransaction[]
  relatedTransactions CoinTransaction[] @relation("UserRelatedTransactions")
  
  // VIP System
  vipPackages       VipPackage[]       @relation("AuthorVipPackages")
  vipSubscriptions  VipSubscription[]  @relation("UserVipSubscriptions")
  authorSubscriptions VipSubscription[] @relation("AuthorVipSubscriptions")

  @@map("users")
}

enum VideoStatus {
  PUBLIC
  VIP
  PRIVATE
  UNLISTED

  @@map("video_status")
}

model Video {
  id             String       @id @default(uuid())
  userId         String       @map("user_id")
  categoryId     String?      @map("category_id")
  title          String
  description    String?
  fileName       String?      @map("file_name")
  fileDirectory  String?      @map("file_directory")
  remotePlayUrl  String?      @map("remote_play_url")
  embedCode      String?      @map("embed_code") @db.Text
  videoUrl       String?      @map("video_url") // Deprecated, kept for backward compatibility
  thumbnailUrl   String?      @map("thumbnail_url")
  thumbnails     String[]     @default([]) // Array of generated thumbnail URLs for selection
  duration       Int?
  fileSize       BigInt?      @map("file_size")
  quality        String[]     @default([]) // Array of available qualities: ["360", "720", "1080"]
  subtitles      String[]     @default([]) // Array of subtitle languages: ["eng", "rus", "tha"]
  tags           String[]     @default([]) // Array of tags
  cost           Int          @default(0) // Cost in coins (0 = free)
  status         VideoStatus  @default(PUBLIC) // PUBLIC, VIP, PRIVATE, UNLISTED
  views          Int          @default(0)
  likes          Int          @default(0)
  comments       Int          @default(0)
  shares         Int          @default(0)
  downloads      Int          @default(0)
  isPublic       Boolean      @default(true) @map("is_public") // Deprecated, use status instead
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @updatedAt @map("updated_at")

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  playlists PlaylistVideo[]
  
  @@index([categoryId])
  @@index([status])
  @@index([userId])
  @@map("videos")
}

model CommunityPost {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  title           String?
  content         String?
  type            PostType
  images          String[]
  videos          String[]
  videoThumbnails String[] @default([]) @map("video_thumbnails") // Video thumbnail filenames, matching videos array order
  fileDirectory   String?  @map("file_directory") // Storage directory for uploaded files
  linkUrl         String?  @map("link_url")
  linkTitle       String?  @map("link_title")
  linkDescription String?  @map("link_description")
  pollOptions     Json?    @map("poll_options")
  pollVotes       Json?    @map("poll_votes")
  tags            String[]
  category        String?
  likes           Int      @default(0)
  comments        Int      @default(0)
  shares          Int      @default(0)
  views           Int      @default(0)
  isPublic        Boolean  @default(true) @map("is_public")

  // New fields for enhanced community posts
  cost            Int      @default(0) @map("cost") // Coins required to view
  requiresVip     Boolean  @default(false) @map("requires_vip") // VIP requirement
  allowComments   Boolean  @default(true) @map("allow_comments") // Allow comments/replies
  allowCommentLinks Boolean @default(false) @map("allow_comment_links") // Allow links in comments
  isPinned        Boolean  @default(false) @map("is_pinned") // Pin this post
  isNsfw          Boolean  @default(false) @map("is_nsfw") // NSFW content
  replyRestriction ReplyRestriction @default(FOLLOWERS) @map("reply_restriction") // Who can reply
  duration        String[] @default([]) @map("duration") // Duration of each video in seconds, matching videos array order

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Social interactions
  likesList     CommunityPostLike[] @relation("PostLikes")
  bookmarksList CommunityPostBookmark[] @relation("PostBookmarks")
  reportsList   CommunityPostReport[] @relation("PostReports")
  unlockedBy    UnlockedPost[]
  
  // Coin transactions
  coinTransactions CoinTransaction[]

  @@map("community_posts")
}

model CommunityPostLike {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user      User           @relation("UserLikes", fields: [userId], references: [id], onDelete: Cascade)
  post      CommunityPost  @relation("PostLikes", fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("community_post_likes")
}

model CommunityPostBookmark {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user      User           @relation("UserBookmarks", fields: [userId], references: [id], onDelete: Cascade)
  post      CommunityPost  @relation("PostBookmarks", fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("community_post_bookmarks")
}

model CommunityPostReport {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  postId      String   @map("post_id")
  reason      String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  user        User           @relation("UserReports", fields: [userId], references: [id], onDelete: Cascade)
  post        CommunityPost  @relation("PostReports", fields: [postId], references: [id], onDelete: Cascade)

  @@map("community_post_reports")
}

model Comment {
  id          String      @id @default(uuid())
  userId      String      @map("user_id")
  contentId   String      @map("content_id")
  contentType ContentType @map("content_type")
  parentId    String?     @map("parent_id")
  content     String
  likes       Int         @default(0)
  isEdited    Boolean     @default(false) @map("is_edited")
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[] @relation("CommentReplies")

  @@map("comments")
}

model Like {
  id          String      @id @default(uuid())
  userId      String      @map("user_id")
  targetId    String?     @map("target_id")
  targetType  String?     @map("target_type")
  contentId   String      @map("content_id")
  contentType ContentType @map("content_type")
  type        LikeType
  createdAt   DateTime    @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId, contentType])
  @@map("likes")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  follower  User @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@map("follows")
}

model UserReport {
  id          String   @id @default(uuid())
  reporterId  String   @map("reporter_id")
  reportedId  String   @map("reported_id")
  reason      String
  description String?
  status      ReportStatus @default(PENDING)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  reporter User @relation("UserReports", fields: [reporterId], references: [id], onDelete: Cascade)
  reported User @relation("UserReported", fields: [reportedId], references: [id], onDelete: Cascade)

  @@map("user_reports")
}

model UserBlock {
  id         String   @id @default(uuid())
  blockerId  String   @map("blocker_id")
  blockedId  String   @map("blocked_id")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  blocker User @relation("UserBlocks", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("UserBlocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("user_blocks")
}

model ChatRoom {
  id        String   @id @default(uuid())
  name      String?
  type      ChatRoomType @default(PRIVATE)
  createdBy String   @map("created_by")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  creator      User                   @relation("ChatRoomCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  participants ChatRoomParticipant[]
  messages     ChatMessage[]

  @@map("chat_rooms")
}

model ChatRoomParticipant {
  id       String   @id @default(uuid())
  roomId   String   @map("room_id")
  userId   String   @map("user_id")
  joinedAt DateTime @default(now()) @map("joined_at")
  lastReadAt DateTime? @map("last_read_at")

  // Relations
  room ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@map("chat_room_participants")
}

model ChatMessage {
  id            String      @id @default(uuid())
  roomId        String      @map("room_id")
  userId        String      @map("user_id")
  content       String
  messageType   MessageType @default(TEXT) @map("message_type")
  fileName      String?     @map("file_name")
  fileDirectory String?     @map("file_directory")
  fileSize      Int?        @map("file_size")
  mimeType      String?     @map("mime_type")
  isEdited      Boolean     @default(false) @map("is_edited")
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  // Relations
  room ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("chat_messages")
}

// Enums
enum PostType {
  TEXT
  LINK
  POLL
  MEDIA

  @@map("post_type")
}

enum ContentType {
  VIDEO
  POST
  COMMENT

  @@map("content_type")
}

enum LikeType {
  LIKE
  DISLIKE

  @@map("like_type")
}

enum ChatRoomType {
  PRIVATE
  GROUP

  @@map("chat_room_type")
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE

  @@map("message_type")
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED

  @@map("report_status")
}

enum ReplyRestriction {
  FOLLOWERS
  PAID_VIEWERS
  FOLLOWING
  VERIFIED_FOLLOWING
  NO_ONE

  @@map("reply_restriction")
}

model Category {
  id            String    @id @default(uuid())
  parentId      String?   @map("parent_id")
  categoryName  String    @map("category_name")
  categoryOrder Int       @default(0) @map("category_order")
  categoryDesc  String?   @map("category_desc")
  categoryThumb String?   @map("category_thumb") // Filename only (e.g., "category-uuid.jpg")
  fileDirectory String?   @map("file_directory") // Format: yyyy/mm/dd
  isDefault     Boolean   @default(false) @map("is_default")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  parent        Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children      Category[] @relation("CategoryHierarchy")
  videos        Video[]

  @@index([parentId])
  @@index([categoryOrder])
  @@map("categories")
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED

  @@map("payment_status")
}

model Payment {
  id              String        @id @default(uuid())
  userId          String        @map("user_id")
  extOrderId      String        @unique @map("ext_order_id")
  amount          Decimal       @db.Decimal(10, 2) // USD amount
  coins           Int           // Coins to be added
  currency        String        @default("BTC") // Cryptocurrency code
  paymentMethod   String?       @map("payment_method") // USDT, CREDIT_CARD, etc.
  status          PaymentStatus @default(PENDING)
  paymentId       String?       @map("payment_id") // MPS internal transaction ID
  paymentAddress  String?       @map("payment_address") // Crypto address
  paymentUri      String?       @map("payment_uri") // Payment URI
  qrCode          String?       @map("qr_code") // Base64 QR code
  transactionId   String?       @map("transaction_id") // Blockchain transaction ID
  metadata        Json?         // Additional payment data
  createdAt       DateTime      @default(now()) @map("created_at")
  completedAt     DateTime?     @map("completed_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  // Relations
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  coinTransactions CoinTransaction[]
  vipSubscriptions VipSubscription[]

  @@index([userId])
  @@index([extOrderId])
  @@index([status])
  @@index([createdAt])
  @@map("payments")
}

model UnlockedPost {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")
  unlockedAt DateTime @default(now()) @map("unlocked_at")

  // Relations
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      CommunityPost  @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId]) // Prevent duplicate unlocks
  @@index([userId])
  @@index([postId])
  @@index([unlockedAt])
  @@map("unlocked_posts")
}

enum CoinTransactionType {
  RECHARGE    // User deposits coins (purchases)
  EARNED      // User earns coins (from post payments, ads, etc.)
  USED        // User spends coins (unlocking posts, subscriptions, etc.)
}

enum CoinTransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

model CoinTransaction {
  id          String                @id @default(uuid())
  userId      String                @map("user_id")
  type        CoinTransactionType
  amount      Int                   // Positive for RECHARGE/EARNED, negative for USED
  status      CoinTransactionStatus @default(COMPLETED)
  description String?               // Human-readable description
  
  // Related entities (optional)
  relatedPostId String?             @map("related_post_id") // For post-related transactions
  relatedUserId String?             @map("related_user_id") // For user-to-user transactions
  paymentId     String?             @map("payment_id")      // Link to payment record
  
  // Metadata
  metadata    Json?                 // Additional data (payment method, etc.)
  createdAt   DateTime              @default(now()) @map("created_at")
  updatedAt   DateTime              @updatedAt @map("updated_at")

  // Relations
  user        User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  relatedPost CommunityPost?        @relation(fields: [relatedPostId], references: [id], onDelete: SetNull)
  relatedUser User?                 @relation("UserRelatedTransactions", fields: [relatedUserId], references: [id], onDelete: SetNull)
  payment     Payment?              @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([userId, type])
  @@index([userId, createdAt])
  @@map("coin_transactions")
}

enum VipPackageDuration {
  ONE_MONTH
  THREE_MONTHS
  SIX_MONTHS
  TWELVE_MONTHS
}

enum VipSubscriptionStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELLED
}

model VipPackage {
  id          String            @id @default(uuid())
  authorId    String            @map("author_id")
  duration    VipPackageDuration
  price       Decimal           @db.Decimal(10, 2) // USD price
  coins       Int               // Coins author earns (price * 100)
  isActive    Boolean           @default(true) @map("is_active")
  createdAt   DateTime          @default(now()) @map("created_at")
  updatedAt   DateTime          @updatedAt @map("updated_at")

  // Relations
  author      User              @relation("AuthorVipPackages", fields: [authorId], references: [id], onDelete: Cascade)
  subscriptions VipSubscription[]

  @@index([authorId])
  @@index([duration])
  @@index([isActive])
  @@map("vip_packages")
}

model VipSubscription {
  id          String                @id @default(uuid())
  subscriberId String               @map("subscriber_id")
  authorId    String                @map("author_id")
  packageId   String                @map("package_id")
  status      VipSubscriptionStatus @default(PENDING)
  startDate   DateTime              @default(now()) @map("start_date")
  endDate     DateTime              @map("end_date")
  paymentId   String?               @map("payment_id")
  createdAt   DateTime              @default(now()) @map("created_at")
  updatedAt   DateTime              @updatedAt @map("updated_at")

  // Relations
  subscriber  User                  @relation("UserVipSubscriptions", fields: [subscriberId], references: [id], onDelete: Cascade)
  author      User                  @relation("AuthorVipSubscriptions", fields: [authorId], references: [id], onDelete: Cascade)
  package     VipPackage            @relation(fields: [packageId], references: [id], onDelete: Cascade)
  payment     Payment?              @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  @@index([subscriberId])
  @@index([authorId])
  @@index([status])
  @@index([endDate])
  @@index([subscriberId, authorId])
  @@map("vip_subscriptions")
}

model Playlist {
  id          String   @id @default(uuid())
  name        String
  description String?
  thumbnailUrl String? @map("thumbnail_url")
  isPublic    Boolean  @default(true) @map("is_public")
  userId      String   @map("user_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  user   User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  videos PlaylistVideo[]

  @@index([userId])
  @@index([isPublic])
  @@map("playlists")
}

model PlaylistVideo {
  id         String   @id @default(uuid())
  playlistId String   @map("playlist_id")
  videoId    String   @map("video_id")
  order      Int      @default(0)
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  video    Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([playlistId, videoId])
  @@index([playlistId])
  @@index([videoId])
  @@map("playlist_videos")
}

// ============================================
// LIBRARY FEATURE - Movies, Episodes, Digital Content
// ============================================

enum MovieContentType {
  MOVIE
  TV_SERIES
  SHORT
  
  @@map("movie_content_type")
}

enum MovieStatus {
  RUMORED
  PLANNED
  IN_PRODUCTION
  POST_PRODUCTION
  RELEASED
  CANCELED
  
  @@map("movie_status")
}

enum ContentSource {
  UPLOAD
  ULOZ
  EXTERNAL
  
  @@map("content_source")
}

enum LibraryContentType {
  EBOOK
  AUDIOBOOK
  MAGAZINE
  COMIC
  
  @@map("library_content_type")
}

model Movie {
  id         String   @id @default(uuid())
  imdbId     String?  @unique @map("imdb_id")
  tmdbId     String?  @map("tmdb_id")
  tvdbId     String?  @map("tvdb_id")
  
  // Basic Info
  title            String   @db.VarChar(500)
  alternativeTitles Json?    @map("alternative_titles") // Array of {title, country, language}
  slug             String   @unique @db.VarChar(500)
  overview         String?  @db.Text
  tagline          String?  @db.Text
  
  // Media
  posterUrl    String? @map("poster_url") @db.Text
  backdropUrl  String? @map("backdrop_url") @db.Text
  photos       Json?   // Array of image URLs
  trailerUrl   String? @map("trailer_url") @db.Text
  sourceUrl    String? @map("source_url") @db.Text // Original source URL (e.g., b4watch.com)
  
  // Classification
  contentType  MovieContentType @default(MOVIE) @map("content_type")
  releaseDate  DateTime?        @map("release_date")
  endDate      DateTime?        @map("end_date") // For TV series
  runtime      Int?             // In minutes
  
  // Categories
  genres       Json?   // Array of genre strings
  countries    Json?   // Array of country codes
  languages    Json?   // Array of language codes
  isAdult      Boolean @default(false) @map("is_adult")
  
  // LGBTQ+ Classification
  lgbtqTypes   Json?   @map("lgbtq_types") // Array: ['gay', 'lesbian', 'bisexual', 'transgender', 'queer']
  
  // Credits
  directors    Json?   // Array of {id, name}
  writers      Json?   // Array of {id, name}
  producers    Json?   // Array of {id, name}
  actors       Json?   // Array of {id, name, character, order}
  
  // Statistics
  voteAverage  Decimal? @map("vote_average") @db.Decimal(3,1)
  voteCount    Int?     @map("vote_count") @default(0)
  popularity   Decimal? @db.Decimal(8,3)
  views        Int      @default(0)
  
  // Status
  status       MovieStatus @default(RELEASED)
  
  // Metadata
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  createdBy    String?  @map("created_by")
  
  // Relations
  episodes     MovieEpisode[]
  
  @@index([imdbId])
  @@index([tmdbId])
  @@index([contentType])
  @@index([releaseDate])
  @@index([status])
  @@map("movies")
}

model MovieEpisode {
  id         String   @id @default(uuid())
  movieId    String   @map("movie_id")
  
  // Episode Info
  episodeNumber Int    @map("episode_number")
  seasonNumber  Int    @default(1) @map("season_number")
  title         String? @db.VarChar(500)
  overview      String? @db.Text
  
  // Media
  thumbnailUrl     String? @map("thumbnail_url") @db.Text
  videoPreviewUrl  String? @map("video_preview_url") @db.Text
  duration         Int?    // In seconds
  
  // File Source (uloz.to)
  source           ContentSource @default(ULOZ)
  slug             String?       @db.VarChar(500)
  folderSlug       String?       @map("folder_slug") @db.VarChar(500)
  parentFolderSlug String?       @map("parent_folder_slug") @db.VarChar(500)
  fileUrl          String?       @map("file_url") @db.Text
  streamUrl        String?       @map("stream_url") @db.Text
  contentType      String?       @default("video") @map("content_type") @db.VarChar(50)
  extension        String?       @db.VarChar(10)
  fileSize         BigInt?       @map("file_size")
  
  // Dates
  airDate      DateTime? @map("air_date")
  
  // Statistics
  views        Int      @default(0)
  
  // Status
  isAvailable  Boolean  @default(true) @map("is_available")
  
  // Metadata
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  
  // Relations
  movie        Movie    @relation(fields: [movieId], references: [id], onDelete: Cascade)
  subtitles    Subtitle[]
  
  @@index([movieId])
  @@index([seasonNumber, episodeNumber])
  @@index([slug])
  @@map("movie_episodes")
}

model Subtitle {
  id        String   @id @default(uuid())
  episodeId String   @map("episode_id")
  
  // Subtitle Info
  language  String   @db.VarChar(10) // ISO 639-2 code (eng, tha, jpn, etc.)
  label     String   @db.VarChar(100) // Display name (English, Thai, Japanese, etc.)
  
  // File Info
  slug      String   @db.VarChar(500)
  fileUrl   String   @map("file_url") @db.Text
  source    ContentSource @default(ULOZ)
  
  // Metadata
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  episode   MovieEpisode @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  
  @@index([episodeId])
  @@index([slug])
  @@map("subtitles")
}

model LibraryContent {
  id          String   @id @default(uuid())
  
  // Basic Info
  title       String   @db.VarChar(500)
  slug        String   @unique @db.VarChar(500)
  description String?  @db.Text
  
  // Media
  coverUrl     String? @map("cover_url") @db.Text
  thumbnailUrl String? @map("thumbnail_url") @db.Text
  
  // Classification
  contentType  LibraryContentType @map("content_type")
  extension    String?            @db.VarChar(10)
  fileSize     BigInt?            @map("file_size")
  
  // Categories
  genres       Json?   // Array of genre strings
  languages    Json?   // Array of language codes
  isAdult      Boolean @default(false) @map("is_adult")
  
  // File Source
  source           ContentSource @default(UPLOAD)
  slugPath         String?       @map("slug_path") @db.VarChar(500)
  fileUrl          String?       @map("file_url") @db.Text
  parentFolderSlug String?       @map("parent_folder_slug") @db.VarChar(500)
  
  // For Gallery Content (magazines, comics)
  pagesCount   Int?    @map("pages_count")
  pagesUrls    Json?   @map("pages_urls") // Array of image URLs
  
  // Metadata
  author        String?   @db.VarChar(500)
  publisher     String?   @db.VarChar(500)
  publishedDate DateTime? @map("published_date")
  isbn          String?   @db.VarChar(20)
  
  // Statistics
  views        Int      @default(0)
  downloads    Int      @default(0)
  
  // Status
  isAvailable  Boolean  @default(true) @map("is_available")
  
  // Metadata
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  createdBy    String?  @map("created_by")
  
  @@index([contentType])
  @@index([slugPath])
  @@map("library_content")
}