name: Deploy Backend to CloudPanel VPS

on:
  push:
    branches:
      - main
      - production
    paths:
      - 'backend/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:

env:
  NODE_VERSION: '18.x'
  PM2_APP_NAME: 'blue-video-backend'
  # Updated: 2025-10-26 - Prisma seed fixes included
  # DEPLOY_PATH will be calculated dynamically in the workflow

jobs:
  deploy:
    name: Deploy to CloudPanel VPS
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: |
          cd backend
          npm ci --production=false

      - name: Generate Prisma Client
        run: |
          cd backend
          npx prisma generate

      - name: Build TypeScript
        run: |
          cd backend
          npm run build:deploy

      - name: Calculate deployment path
        id: deploy_path
        run: |
          # Use BACKEND_DEPLOY_PATH if set, otherwise construct from VPS_USERNAME and API_URL
          if [ -n "${{ secrets.BACKEND_DEPLOY_PATH }}" ]; then
            DEPLOY_PATH="${{ secrets.BACKEND_DEPLOY_PATH }}"
            echo "âœ… Using BACKEND_DEPLOY_PATH: $DEPLOY_PATH"
          else
            # Get VPS_USERNAME and API_URL/BACKEND_URL
            VPS_USERNAME="${{ secrets.VPS_USERNAME }}"
            API_URL="${{ secrets.BACKEND_URL || secrets.API_URL }}"
            
            if [ -z "$VPS_USERNAME" ]; then
              echo "âŒ Error: VPS_USERNAME secret is required when BACKEND_DEPLOY_PATH is not set"
              exit 1
            fi
            
            if [ -z "$API_URL" ]; then
              echo "âŒ Error: BACKEND_URL or API_URL secret is required when BACKEND_DEPLOY_PATH is not set"
              exit 1
            fi
            
            # Extract domain from URL (remove protocol and path)
            DOMAIN=$(echo "$API_URL" | sed -E 's|^https?://||' | sed -E 's|/.*||')
            DEPLOY_PATH="/home/$VPS_USERNAME/htdocs/$DOMAIN"
            echo "âœ… Constructed DEPLOY_PATH from VPS_USERNAME and API_URL: $DEPLOY_PATH"
          fi
          
          echo "DEPLOY_PATH=$DEPLOY_PATH" >> $GITHUB_OUTPUT
          echo "ğŸ“ Final deployment path: $DEPLOY_PATH"

      - name: Create deployment package
        run: |
          cd backend
          mkdir -p deploy
          
          # Copy essential files
          echo "ğŸ“¦ Copying dist directory..."
          cp -r dist deploy/
          
          echo "ğŸ“¦ Copying node_modules..."
          cp -r node_modules deploy/
          
          echo "ğŸ“¦ Copying prisma directory..."
          cp -r prisma deploy/
          
          echo "ğŸ“¦ Copying package files..."
          cp package*.json deploy/
          cp tsconfig.json deploy/
          
          # Copy environment file template (will be replaced on server)
          if [ -f .env.example ]; then
            cp .env.example deploy/.env.example
          fi
          
          # Verify prisma directory was copied
          echo "âœ… Verifying deploy contents..."
          ls -la deploy/
          echo "âœ… Prisma directory contents:"
          ls -la deploy/prisma/
          
          # Create tarball
          cd deploy
          tar -czf ../backend-deploy.tar.gz .
          cd ..
          
          echo "âœ… Deployment package created: backend-deploy.tar.gz"
          ls -lh backend-deploy.tar.gz
          
          # Verify tarball contents
          echo "âœ… Tarball contents:"
          tar -tzf backend-deploy.tar.gz | grep -E "^prisma/" | head -10

      - name: Deploy to VPS via SSH
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_SSH_PORT || 22 }}
          source: "backend/backend-deploy.tar.gz"
          target: "/tmp/"
          strip_components: 1

      - name: Extract and restart application
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_SSH_PORT || 22 }}
          script: |
            set -e
            
            echo "ğŸš€ Starting deployment..."
            
            # Load NVM and Node.js (CloudPanel uses NVM)
            export NVM_DIR="$HOME/.nvm"
            if [ -s "$NVM_DIR/nvm.sh" ]; then
              . "$NVM_DIR/nvm.sh"
              echo "âœ… NVM loaded"
            fi
            
            # Use Node.js 18.x
            if command -v nvm &> /dev/null; then
              nvm use 18 || nvm install 18
              echo "âœ… Node.js $(node -v) activated"
            fi
            
            # Verify npm is available
            if ! command -v npm &> /dev/null; then
              echo "âŒ npm not found even after loading NVM!"
              echo "PATH: $PATH"
              echo "Node: $(which node || echo 'not found')"
              exit 1
            fi
            
            echo "ğŸ“ Using npm: $(which npm)"
            echo "ğŸ“ Using node: $(which node)"
            echo "ğŸ“ Node version: $(node -v)"
            echo "ğŸ“ npm version: $(npm -v)"
            
            # Set deployment path from workflow output
            export DEPLOY_PATH="${{ steps.deploy_path.outputs.DEPLOY_PATH }}"
            echo "ğŸ“ Deployment path: $DEPLOY_PATH"
            
            # Navigate to deployment directory
            cd "$DEPLOY_PATH"
            
            # Backup current deployment
            if [ -d "current" ]; then
              echo "ğŸ“¦ Creating backup..."
              BACKUP_DIR="backup-$(date +%Y%m%d-%H%M%S)"
              mkdir -p backups
              mv current backups/$BACKUP_DIR
              echo "âœ… Backup created: backups/$BACKUP_DIR"
            fi
            
            # Extract new deployment
            echo "ğŸ“‚ Extracting new deployment..."
            mkdir -p current
            tar -xzf /tmp/backend-deploy.tar.gz -C current/
            rm /tmp/backend-deploy.tar.gz
            
            # Navigate to current deployment
            cd current
            
            # Preserve .env file from previous deployment or create from example
            if [ -d "../backups" ] && [ "$(ls -A ../backups 2>/dev/null)" ]; then
              LATEST_BACKUP=$(ls -t ../backups | head -1)
              if [ -f "../backups/$LATEST_BACKUP/.env" ]; then
                echo "ğŸ”§ Copying .env from backup..."
                cp "../backups/$LATEST_BACKUP/.env" .env
              fi
            fi
            
            # If no .env exists, create from example
            if [ ! -f ".env" ]; then
              echo "âš ï¸  .env file not found. Please create one manually!"
              if [ -f ".env.example" ]; then
                cp .env.example .env
                echo "ğŸ“ Created .env from .env.example - UPDATE WITH REAL VALUES!"
                echo ""
                echo "âš ï¸  IMPORTANT: Update .env file with real database credentials!"
                echo "   Edit: $DEPLOY_PATH/current/.env"
                echo ""
              fi
            else
              echo "âœ… Using existing .env file"
            fi
            
            # Install production dependencies (in case any are missing)
            echo "ğŸ“¦ Installing production dependencies..."
            npm ci --production
            
            # Generate Prisma client (in case of schema changes)
            echo "ğŸ”¨ Generating Prisma client..."
            npx prisma generate
            
            # Push database schema (create/update tables)
            echo "ğŸ—„ï¸  Pushing database schema..."
            if npx prisma db push --skip-generate 2>&1 | tee /tmp/prisma-push.log | grep -q "P1000\|P1001\|P1002"; then
              echo "âš ï¸  Database connection failed - skipping schema push"
              echo "   Configure database credentials in .env and run manually:"
              echo "   cd $DEPLOY_PATH/current && npx prisma db push"
            else
              if grep -q "Your database is now in sync with your Prisma schema\|Database schema was successfully updated" /tmp/prisma-push.log; then
                echo "âœ… Database schema updated successfully"
              else
                echo "âœ… Schema push completed"
              fi
            fi
            
            # Restart application with PM2
            echo "ğŸ”„ Restarting application..."
            
            # Check if PM2 is installed
            if ! command -v pm2 &> /dev/null; then
              echo "âŒ PM2 is not installed. Installing globally..."
              npm install -g pm2
            fi
            
            # Check if app is already running
            if pm2 describe ${{ env.PM2_APP_NAME }} > /dev/null 2>&1; then
              echo "ğŸ”„ Reloading existing PM2 process..."
              pm2 reload ${{ env.PM2_APP_NAME }} --update-env
            else
              echo "ğŸš€ Starting new PM2 process..."
              pm2 start dist/server.js \
                --name ${{ env.PM2_APP_NAME }} \
                --time \
                -i 2 \
                --max-memory-restart 500M
            fi
            
            # Save PM2 configuration
            pm2 save
            
            # Display application status
            echo "âœ… Deployment completed!"
            pm2 status
            pm2 logs ${{ env.PM2_APP_NAME }} --lines 50 --nostream
            
            # Keep only last 5 backups
            echo "ğŸ§¹ Cleaning old backups..."
            if [ -d "../backups" ]; then
              cd ../backups
              ls -t | tail -n +6 | xargs -r rm -rf
            fi
            
            echo "ğŸ‰ Deployment successful!"

      - name: Health check
        run: |
          echo "ğŸ¥ Performing health check..."
          sleep 10
          
          # Use BACKEND_URL if set, otherwise fall back to API_URL
          API_URL="${{ secrets.BACKEND_URL || secrets.API_URL }}"
          if [ -z "$API_URL" ]; then
            echo "âš ï¸  No API URL configured for health check"
            exit 0
          fi
          HEALTH_URL="$API_URL/health"
          
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s "$HEALTH_URL" > /dev/null; then
              echo "âœ… Health check passed!"
              curl -s "$HEALTH_URL" | jq . || curl -s "$HEALTH_URL"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "â³ Health check attempt $RETRY_COUNT/$MAX_RETRIES failed. Retrying in 5s..."
              sleep 5
            fi
          done
          
          echo "âŒ Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Notify on success
        if: success()
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸ“ Deployed to: ${{ secrets.VPS_HOST }}"
          echo "ğŸ• Time: $(date)"
          echo "ğŸ“ Commit: ${{ github.sha }}"
          echo "ğŸ‘¤ Author: ${{ github.actor }}"

      - name: Notify on failure
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "ğŸ“ Host: ${{ secrets.VPS_HOST }}"
          echo "ğŸ• Time: $(date)"
          echo "ğŸ“ Commit: ${{ github.sha }}"
          echo "ğŸ‘¤ Author: ${{ github.actor }}"
          echo "âš ï¸  Check the logs above for details"

      - name: Cleanup
        if: always()
        run: |
          cd backend
          rm -f backend-deploy.tar.gz
